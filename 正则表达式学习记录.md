# 正则表达式基础学习记录 #
<font color='red'>**不同环境下正则表达式的语法不尽相同，本文所有示例均基于Java环境**</font>
<br />

### 一、基本匹配规则 ###
1. ** . ：** 通配符,匹配任意一个字符
2. ** ^ ：** 匹配字符串的开始位置，<font color='red'>当出现在以[ ]表示的字符集合的**开头**时，表示‘非’，如：[^\d]匹配除阿拉伯数字以外的其他字符，但若出现在字符串中间则会被当成普通字符处理，若打算匹配‘^’开头的字符串，则需要加上转义字符，如 \^a </font>
3. ** $ ：** 匹配字符串结束的位置
4. ** \d ：** 匹配任意一个阿拉伯数字
5. ** \D ：** 匹配除阿拉伯数字外,任意一个字符
6. ** \w： ** 匹配字母数字下划线，即单词字符
7. ** \W： ** 匹配非单词字符，即除了字母数字下划线以外的其他字符
8. ** \s： ** 匹配空白字符，空白字符指空格、制表符（\t）、换行符（\n）、回车（\r）
9. ** \S： ** 匹配非空白字符
10. ** \b： ** 匹配单词边界<font color='red'>在Java与JavaScript中，单词由字母数字下划线构成，.net由[a-zA-Z0-9]以及Unicode字符（汉字和全角符号等）构成</font>
11. ** \B： ** 匹配非单词边界
> 边界是一个位置，不代表任何字符。如“张三”，‘张’和‘三’中间就是一个位置，单词边界就是单词字符与非单词字符之间的位置。用文字描述可能比较抽象，举几个例子试一下就明白了。
> * 用(le\b)以及(le\W分别匹配“apple&”，结果分别是‘le’和‘le&’。
> * 用(\b)匹配“apple”中 单词边界出现的次数，结果是两次，开头和结尾。
> * 用(\b)匹配“app=le”是四次，开头和结尾加上等号两边。
> * 用(\b)匹配“app==le”还是四次，因为两个等号都不是单词字符，所以它们之间的位置不是单词边界。
> * 用(\b)匹配“ap=pl=e”是六次，开头和结尾、第一个等号两侧、第二个等号两侧。

*常用的这些就够了，像制表符、垂直制表符、换行符、换页符等，一是不常用，二是不同环境下不一定相同，等到用的时候再百度就可以了。*

### 二、量词 ###
&nbsp;&nbsp;&nbsp;&nbsp;跟在元字符后面，用来修饰元字符的数量
1. **\* ：** 任意次数
2. **? ：** 0次或者1次（问号可以理解为疑问，有还是没有？没有是出现0次，有是出现1次。这样好记一点）
3. **+ ：** 1次或者多次（加号可以理解为多个，即至少会有一个）
4. **{m}：** 出现m次
5. **{m，}：** 出现至少m次
6. <font color='red'>**{，n} ：** 注意了，没有这种写法，不能这样匹配最多出现次数</font>
7. **{m,n}：** 出现次数大于等于m小于等于n  

### 三、分组和后向引用 ###
&nbsp;&nbsp;&nbsp;&nbsp;被()包裹的内容会被捕获，并被保存到一个临时缓冲区当中，在后面可以使用\1或者$1来引用，如“（ab）cd\1” = “abcdab”，Java和Linux的sed命令只支持\1这一种引用方式，但是Perl两种都支持。需要注意的是引用的的位置要在捕获位置之后，且引用的序号必须是正确的。
> * "\1(a)bcd"这种只能匹配到abcd。
> * "(a)bcd\0"或者"(a)bcd\2"这种写法匹配不到任何字符串。
> * 想引用第11个捕获时，只需要\11即可，但若是想引用第一个捕获、后面的1只代表阿拉伯数字1时，可以写成\1[1]的形式,使用\1(1)同样可以达到目的，但是因为使用()会多出将捕获的分组保存到内存中的步骤，进而影响效率。

&nbsp;&nbsp;&nbsp;&nbsp;使用数字引用可能会造成混淆，这个时候可以对捕获分组进行命名，使用命名分组的形式进行引用。在()捕获的内容最前面使用"?<name>"进行命名，如：(?&lt;my&gt;a),使用时用"\k&lt;my&gt;进行引用。

### 四、正前瞻、反前瞻、正后顾、反后顾 ###
&nbsp;&nbsp;&nbsp;&nbsp;这四个名词都是限定要匹配的正则前后是否为特定字符
* 正前瞻：a(?=b)，匹配后边是字母b的字母a
* 反前瞻：a(?!b)，匹配后边不是字母b的字母a
* 正后顾：(?<=a)b，匹配前面是字母a的字母b
* 反后顾：(?<!a)b，匹配前面不是字母a的字母b